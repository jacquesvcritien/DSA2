
			\documentclass{article}
			\usepackage{graphicx}
			\usepackage{listings}
			\usepackage{titlepic}
			\usepackage[margin=1in]{geometry}
			\usepackage{float}
			\usepackage{hyperref}
			\newcommand\tab[1][1cm]{\hspace*{#1}}
			\newcommand{\quotes}[1]{``#1''}
			\usepackage{multicol}
			\renewcommand{\labelenumii}{\theenumii}
			\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}
			
			\begin{document}
			\title{\includegraphics[scale = .6]{uom.png}
				\linebreak 
				\textbf{ICS2210 - Data Structures and Algorithms 2}\linebreak\linebreak
				\textbf{Project Coursework 2020}\linebreak\linebreak
				\large{B.Sc Computer Science}
				\date{}
				\author{Jacques Vella Critien - 97500L}}
				
				\begin{titlepage}
					\maketitle
					\thispagestyle{empty}
				\end{titlepage}
				
				\tableofcontents
				\newpage
				
				\section{Task1: Boolean Satisfiability}
				
				In this task, we were required to write a command line program that accepts Boolean expressions in Conjunctive Normal Form (CNF). Moreover, this implementation should:
				
				\begin{itemize}
				\item accept symbols \quotes{w}, \quotes{x}, \quotes{y} and \quotes{z} to represent literals
				\item use the \quotes{!} symbol to represent negation
				\item use parenthesis to group clauses
				\item use commas	to	separate literals	in	clauses
				\item white-space is irrelevant and should be ignored while parsing
				\end{itemize} 
				
				\noindent Moreover, the Davis-Putnam-Logemann-Loveland (DPLL) algorithm had to be implemented to determine whether the expression is satisfiable. If the expression is satisfiable the program should display a truth assignment as a proof, while if it is unsatisfiable, the program should display \quotes{UNSAT}.\\
				
\noindent Finally, we are to dedicate a section to describe the practical applications of SAT. 

		\subsection{Solution}
		
		\subsubsection{SyntaxErrorException.java}
		
		This is an exception thrown when there is something wrong with the string passed to be parsed by the parser
		
		
		\subsubsection{Assignment.java}
		
		This is an enum to hold the assignment value and this can be either TRUE, FALSE or DONTCARE.
		
		\subsubsection{Symbol.java}
		
		The assignment states that the implementation should include the values  \quotes{w}, \quotes{x}, \quotes{y} and \quotes{z} but in this enum class which contains the different symbols available for literals or variables, I also added  \quotes{v} for more testing.
		
		\subsubsection{Literal.java}
		
		This is a class which represents a literal. It has the following member variables:
		\begin{itemize}
		\item \textbf{negated}: This is a boolean to hold if the literal is negated or not
		\item \textbf{symbol}: This is of type Symbol explained above and is used to hold the symbol or type of the literal.
		\end{itemize}
		
		In addition, this class consists of the following methods
		
		\begin{enumerate}
		\item \textbf{Literal(String)}: This is a constructor that when given a string it initialises the literal object from it. This is done by first checking if the length of the string passed is greater than 2 or if the length is 2 and that the first character is 2. If so, it means that the string passed is not of the correct format, therefore a \textbf{SyntaxErrorException} is thrown. Otherwise, it is checked whether the passed literal is negated by checking if the size is 2, if so meaning that it is negated and if not, it means that the literal is not negated. The last step involves obtaining the symbol of the literal from the string and setting it. In case of a symbol different from the accepted ones, a \textbf{SyntaxErrorException} is thrown.
		
		\item \textbf{isNegated()}: This is a getter for the negated member variable.
		\item \textbf{setNegated(boolean)}: This is a setter for the negated member variable.		
		\item \textbf{getSymbol()}: This is a getter for the symbol member variable.
		\item \textbf{setSymbol(Symbol)}: This is a setter for the symbol member variable.	
		\item \textbf{equals(Literal)}: This is a method to check if the current literal is equal to the one passed. This is done by checking if both literals contain the same symbol and negation.
		\item \textbf{clone()}: This is a method to clone a literal, i.e., getting its values, setting them to a new Literal object and returning it.
		
		\end{enumerate}
		
		\subsubsection{Clause.java}
		
		This is a class which represents a clause. It has the following member variable:
		\begin{itemize}
		\item \textbf{literals}: This is an arraylist of Literals, used to hold the literals in the clause.
		\end{itemize}
		
		In addition, this class consists of the following methods
		
		\begin{enumerate}
		\item \textbf{Clause(ArrayList\textless Literal\textgreater)}: This is a constructor that when given an array-list of literals, they are set to member variable holding literals.
		
		\item \textbf{Clause()}: This is an empty constructor for clause and it just initialises the array-list of literals.
		\item \textbf{getLiterals()}: This is a getter for the literals member variable.		
		\item \textbf{addLiteral(Literal)}: This is a function which just adds a literal to the array-list holding literals.
		
		
		\end{enumerate}
		
		\subsubsection{Parser.java}
		
		This is the class used to represent the parser, hence which turns boolean expressions as strings and parses them into objects of clauses and literals. Moreover, this performs error checking to make sure that these expressions are entered in the correct format. 
		
		This class contains the following methods:
		
			\begin{enumerate}
		\item \textbf{parseString(String)}: This function is the main function used to parse a string into proper objects of clauses and literals by returning a set of clauses\\
		This is done by first checking making sure that the string is not empty and if so a \textbf{SyntaxErrorException} is thrown. The next step involves removing all white-spaces before checking whether the first character of the string is a `(` and the last character of the string is a `)` and if not, a \textbf{SyntaxErrorException} is thrown.\\\\
		After these checks, the parsing starts by removing the first and last characters which should be `(` and a `)` and then create a string tokenizer with the delimeter set to `)(` so that each clause is seperated. The next step involves going through each token stored by the clause tokenizer and for every token, a new clause object is created and each literal is obtained by creating another tokenizer, this time operating with the delimeter set to `,`. Before moving to the next step, it is worth mentioning that, the DPLL class, which will be explained in the next section, contains a member variable of type hashmap with the a Symbol key and an Assignment enum value as value, called \textbf{assignments} to hold assignments, i.e. every literal symbol being used in the clause. \\\\
		After this, for every literal in each clause, a new Literal is created by calling the literal constructor accepting a string and if the \textbf{assignments} map does not contain the symbol, the symbol is added to the list with a DONTCARE assignment. Finally, the literal is added to the clause created in the loop containing the clauses and once all the literals of the clause are iterated through, the clause is added to the set of clauses to be returned. \\\\
		After all the literals and clauses are visited, the set of clauses which was filled is returned.
		
		
		\item \textbf{printParsed(Set\textless Clause\textgreater}: This function is used to print the passed set of clauses in a parsed way. This is done by creating an iterator on the set of clauses and for each clause, the literals are obtained and are printed. If these are negated, a `$\neg$` before the symbol is printed. The clauses and literals are also numbered to make it easier for the user to understand them, for an example, one can take a look at the figure below.
		
						\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.55\textwidth]{printparsed.png}
			 			\centering
			  			\caption{Result for (!x)(y, x)(z,w)(y, w)}
			  			\label{fig:printparsed}
					\end{figure}
					
		
		\end{enumerate}
		
				\subsubsection{DPLL.java}
				
				This class contains methods for the DPLL algorithm and the actual DPLL function. 
				Moreover, this class has the following global variable:
		
		\begin{itemize}
		\item \textbf{assignments}: This is a hashmap with a key of type Symbol and a value of type Assignment. This variable is ought to hold each symbol found in the expression and keep its assignments so that if it is satisfiable, the assignments, computed on run-time can be easily displayed.
		\end{itemize}
				
	This class contains the following methods:
	
		\begin{enumerate}
		\item \textbf{removeTriviallySat(Set \textless Clause\textgreater)}: This method removes the trivially satisfiable, of the form (x, !x), clauses from the passed set of clauses and returns a set of clauses without the satisfiable clauses. In order to do this, a boolean flag named removed is held and an iterator is initiated based on the elements inside the passed set of clauses. 
		\\\\
		For every clause found in the iterator, removed is set to false, and the clause's literals are obtained. Apart from this, for every clause, there is an inner loop which goes through each literal in the clause until there is a removal or all literals have been iterated. Inside this loop, there is another nested loop to go through the literals one more time for comparison and if the literal of the outer loop and the literal of the inner loop are of the same symbol but their negation is different, hence in the form (x, !x), this clause is removed and removed is set to true. Finally, the remaining clauses are added. To help in the explanation the code snippet of this method can be found in the below image.
		
								\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.8\textwidth]{removesat.png}
			 			\centering
			  			\caption{Code snipped for how to remove trivially satisfiable clauses}
			  			\label{fig:removesat}
					\end{figure}
		
		\item \textbf{checkTriviallyUnSat(Set \textless Clause\textgreater)}: This is a method which checks if there are any trivially unsatisfiable clauses, of the form (x)(!x), from a set of clauses. This is done by looping through all clauses and comparing them with each other.\\\\
		To do this, an iterator is used for the first loop which goes on until the iterator has another value. The first thing done in the first loop is to check if the the amount is literals inside the clause is 1 because if not, it cannot be an unsatisfiable clause, therefore, the loop proceeds to the next clause. Inside this loop, another iterator is obtained for the same clauses to compare and a nested loop is created to go through the clauses again.\\\\
		Inside the nested loop, the clause is obtained and the check for the amount of literals is done once again and if the size is not 1, this clause is skipped. If not, the literal from the first clause (outer loop) and the literal from the second clause (inner loop) are obtained. If these literals are of the same symbol and they have opposite negation, it must mean that they are of the form (x)(!x), hence, trivially unsatisfiable and true is returned. If no two clauses are found to be trivially unsatisfiable, false is returned.
		
		\item \textbf{checkEmptyClause(Set \textless Clause\textgreater)}: This is a function which checks if there are any empty clauses in the set of clauses passed as parameters. This is done by iterating through all the clauses and if the clause has no literal, true is returned.
		
		\item \textbf{getUnitClause(Set \textless Clause\textgreater)}: A unit clause is a clause containing only 1 literak, This is a function which returns a unit clause if there is one from the passed clauses and null if there is not. This is done by going through the clauses using an iterator and if the clause has only 1 literal, a copy of the clause is cloned and returned.
		
		\item \textbf{getPureLiteral(Set \textless Clause\textgreater)}: This is a function which returns a pure literal from the list of passed clauses. A pure literal is a literal which appears either positive or negative throughout all clauses. This is started by keeping a boolean flag named searching, initiating an arraylist of literals and adding all literals in all clauses in it. \\\\
		After this, there is a loop through all these literals. Inside this loop, the first thing we do is set the boolean flag searching to true and get the current literal. Then there a nested loop to go through the literals again for comparison and if the symbol from the first literal, is the same as the symbol from the literal in the nested loop and their negation is opposite, searching is set to false and we break out of the loop because it means that the outer literal is not pure. After the nested loop, there is a check for searching and if this is true, a clone of the literal in the outer loop is returned because it means that it is pure. If searching is always false, null is eventually returned.
		
				\item \textbf{exhaustivelyApply1LiteralRule(Clause, Set \textless Clause\textgreater)}: This is a function which given a unit clause and a set of clauses, returns a set of clauses after performing the 1 literal rule exhaustively on the passed set of clauses using the passed clause. \\
				
				This is done by looping through all clauses and doing the following:
				\begin{itemize}
				\item Getting current clause and its literals from iterator and getting the first literal from the passed unit clause
				\item Looping through each literal from the literals of the current clause and inside this loop:
					\begin{itemize}
						\item The current literal is obtained
						\item The unit clause literals negation value is inverted (so if it's not negated, negate it and vice-versa)
						\item If the current literal is equal to the unit clause inverted, the current literal is removed from the set of literals of its parent clause.
						\item The unit clause literal is re-inverted to its original negation
						\item It is checked if the current clause is equal to the unit clause and if so, the clause is removed and the loop is broken.

					\end{itemize}
				
					
				\end{itemize}
				
		Finally, the remaining clauses with their remaining literals are returned
	
		\item \textbf{applyPureLiteralRule(Literal, Set \textless Clause\textgreater)}: This is a function which returns a set of clauses after applying the pure literal rule exhaustively on the set of clauses passed using the passed pure literal. This is done by going through each clause in the passed clauses and then for each, clause there is another loop for each literal in this clause. If this literal is equal to the pure literal, the current clause in the loop is removed and the loop is broken. Finally the clauses are returned once all the clauses are traversed.
						
		\item \textbf{chooseLiteral(Set \textless Clause\textgreater)}: This function is a heuristic and from my research, I decided to implement it based on the \textbf{Dynamic Largest Individual Sum(DLIS)}, meaning that each literal is binned and the variable with maximal max(CP, CN) is selected, with CP and CN being the number of positive and negative occurrences. So this function, given a set of clauses, returns the most frequent literal. \\
		
		This is done by first initialising a hashmap with a key of type Literal and a value of type Integer, named bins to hold the number of occurrences. Then, the all the literals in all the clauses are stored in an arraylist and each literal from this arraylist is traversed and if the bins contained the literal, the value of the bin for that literal would be incremented, otherwise a new entry in the bin hashmap is created with the currently visited literal. After this, the maximum from the bins is obtained and a new literal with the symbol of the most frequent literal is returned.
		
		\item \textbf{DPLL(Set \textless Clause\textgreater)}: This function is the function that actually implements the Davis-Putnam-Logemann-Loveland algorithm which can be found below. This recursive function is passed a set of clauses and returns whether the boolean expression made up of the passed clauses is satisfiable.
		
					\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dpllalgo.png}
			 			\centering
			  			\caption{DPLL algorithm from the notes}
			  			\label{fig:dpllalgo}
					\end{figure}
		
		This is done by first removing trivially satisfiable clauses by calling \textbf{removeTriviallySat()} with the passed clauses as parameters. Then, it is checked if there are any trivially unsatisfiable clauses by calling \textbf{checkTriviallyUnSat()} with the passed clauses as parameters and if so, `UNSAT` is printed and false is returned.
		Otherwise, it is checked if there are any empty clauses by calling \textbf{checkEmptyClause()} with the passed clauses as parameters and if so, \quotes{UNSAT} is printed and false is returned.
		Then, if not, it is checked whether clauses is empty because if this is the case, we can say that the boolean expression is satisfiable and therefore, the assignments stored in the assignments global variable are printed one by one and true is returned.\\\\
		The above were the base cases, and if none were reached, it means that we still have to perform some more operations before we get to know whether the expression is satisfiable or not. This is done by getting unit clauses one by one by calling \textbf{getUnitClause()} with the passed clauses as parameters and for each one, an assignment is set with the unit clause only literal's symbol as key and if it is negated the assignment is FALSE, otherwise, it is true. Moreover, for every unit clause, the 1-literal rule is applied exhaustively by calling \textbf{exhaustivelyApply1LiteralRule()} with the unit clause and clauses as parameters. \\\\
		The next step involves getting the pure literals one by one by calling \textbf{getPureLiteral()} with the passed clauses as parameters and for each one, an assignment is set with the pure literals's symbol as key and if it is negated the assignment is FALSE, otherwise, it is true. Moreover, for every pure literal, the pure literal rule is applied exhaustively by calling \textbf{applyPureLiteralRule()} with the pure literal and clauses as parameters. \\\\ 
		The final step involves getting a literal by calling the heuristic function \textbf{chooseLiterals()} with the remaining clauses as parameters. After this, a copy of the clauses is made and a positive literal of the symbol chosen is added to one copy of set of clauses while a negative literal of the symbol chosen by  \textbf{chooseLiterals()} is added to the other copy of set of clauses. Finally, these sets of clauses are then used as parameters to recall this function recursively until a base case is reached.
		
						
		\end{enumerate}					
		
		
\subsection{How to run}

In order to run the implementation for task 1, an additional class named \textbf{ParserExecutor} was created and in its main method, the command line arguments are obtained. These are joined together using a string builder and then they are parsed into clauses by calling the function \textbf{parseString(String)}. Finally, the function \textbf{DPLL()} is called with the clauses generated form the arguments to start checking the expression's satisfiability. \textbf{It is important to note that the quotes before and after the expression may change according to the machine}.

\begin{enumerate}
\item Go to the directory \quotes{DSA2}
\item Run \textbf{java -jar .\textbackslash Task1-1.0.jar \quotes{\textless anyExpression\textgreater}}
\end{enumerate}

		\subsection{Testing}
		
	My implementation was tested by having unit tests for the methods in the literal and parser class. Moreover some integration tests were done to make sure that the DPLL method returns the expected the results.\\
	It was made sure that all the code is hit by tests and this can be confirmed by having 100\% test coverage as can be seen in the following figure.
	
		\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.9\textwidth]{task1cov.png}
			 			\centering
			  			\caption{Code coverage for task 1}
			  			\label{fig:task1cov}
					\end{figure}
	
	
	A breakdown of these tests can be found in the explanation below.

	\subsubsection{LiteralTest.java}
	
	This testing class contains tests for the constructor method by passing some valid and invalid strings and it is asserted that the correct Literal object or exception is returned. Moreover, tests for the overridden \textbf{equals(Literal)} method were implemented to test all the possible cases.\\
	The following is a list of all the tests found in this class
	

	\begin{enumerate}
		\item \textbf{Incorrect literal size test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to see the reaction of the literal constructor when given a literal of an incorrect size, 5 in this case\\\\
		\underline{Input}\\
		\indent The input as literal is \quotes{(xyz)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is a SyntaxErrorException being thrown.\\\\
		\underline{Actual Output}\\
		\indent A SyntaxErrorException was thrown hence, this test passed.\\
		
		\item \textbf{Incorrect literal format}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to see the reaction of the literal constructor when given a literal of incorrect format, in this case, a literal of size 2 but with no !\\\\
		\underline{Input}\\
		\indent The input as literal is \quotes{xz}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is a SyntaxErrorException being thrown.\\\\
		\underline{Actual Output}\\
		\indent A SyntaxErrorException was thrown hence, this test passed.\\
		
		\item \textbf{Equal literal test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is test the equals method for the literals by creating two literals with the same symbol and negation and calling equals on them\\\\
		\underline{Input}\\
		\indent The two literals are equal to \quotes{y}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is true.\\\\
		\underline{Actual Output}\\
		\indent The result was true hence, this test passed.\\
		
				
		\item \textbf{Not equal literal test different symbol}\\\\
		\underline{Description}\\
		\indent This purpose of this test is test the equals method for the literals by creating two literals with the same negation but a different symbol\\\\
		\underline{Input}\\
		\indent The first literal was \quotes{y} and the second literal was \quotes{x}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is false.\\\\
		\underline{Actual Output}\\
		\indent The result was false hence, this test passed.\\
		
				
		\item \textbf{Not equal literal test different negation}\\\\
		\underline{Description}\\
		\indent This purpose of this test is test the equals method for the literals by creating two literals with the same symbol but a different negation\\\\
		\underline{Input}\\
		\indent The first literal was \quotes{y} and the second literal was \quotes{$\neg$y}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is false.\\\\
		\underline{Actual Output}\\
		\indent The result was false hence, this test passed.\\
		
		\item \textbf{Not equal literal test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is test the equals method for the literals by creating two literals with a different symbol and a different negation\\\\
		\underline{Input}\\
		\indent The first literal was \quotes{y} and the second literal was \quotes{$\neg$x}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is false.\\\\
		\underline{Actual Output}\\
		\indent The result was false hence, this test passed.\\
		
		\item \textbf{Not equal when null}\\\\
		\underline{Description}\\
		\indent This purpose of this test is test the equals method when comparing a literal with a null.\\\\
		\underline{Input}\\
		\indent The first literal was \quotes{y} and the second literal was null\\	\\
		\underline{Expected Output}\\
		\indent The expected output is false.\\\\
		\underline{Actual Output}\\
		\indent The result was false hence, this test passed.\\
		
		\item \textbf{Same literal equal test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is test the equals method when calling equals on the same object\\\\
		\underline{Input}\\
		\indent The same literal object with value \quotes{y} was compared\\	\\
		\underline{Expected Output}\\
		\indent The expected output is true.\\\\
		\underline{Actual Output}\\
		\indent The result was true hence, this test passed.\\
	\end{enumerate}
	
	\subsubsection{ParserTest.java}
	
	This testing class contains tests for the \textbf{parseString(String)} method by passing correct and incorrect strings and then asserting that the expected set of clauses are returned or that a \textbf{SyntaxErrorException} is thrown in case a string is not of the correct format.\\
	The following is a list of all the tests found in this class
	

	\begin{enumerate}
		\item \textbf{Parse empty string test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to see the reaction of the parseString() method when given an empty string\\\\
		\underline{Input}\\
		\indent The input is an empty string\\	\\
		\underline{Expected Output}\\
		\indent The expected output is a SyntaxErrorException being thrown.\\\\
		\underline{Actual Output}\\
		\indent A SyntaxErrorException was thrown hence, this test passed.\\
		
		\item \textbf{Parse string with no starting parenthesis test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to see the reaction of the parseString() method when given a string with no starting parenthesis\\\\
		\underline{Input}\\
		\indent The input as literal is \quotes{x,y)(x,y)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is a SyntaxErrorException being thrown.\\\\
		\underline{Actual Output}\\
		\indent A SyntaxErrorException was thrown hence, this test passed.\\
		
		\item \textbf{Parse string with no ending parenthesis test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to see the reaction of the parseString() method when given a string with no ending parenthesis\\\\
		\underline{Input}\\
		\indent The input as literal is \quotes{(x,y)(x,y}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is a SyntaxErrorException being thrown.\\\\
		\underline{Actual Output}\\
		\indent A SyntaxErrorException was thrown hence, this test passed.\\
		
				
		\item \textbf{Parse string with incorrect symbols test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to see the reaction of the parseString() method when given a string unsupported symbols\\\\
		\underline{Input}\\
		\indent The input as literal is \quotes{(a,y)(c,y)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output is a SyntaxErrorException being thrown.\\\\
		\underline{Actual Output}\\
		\indent A SyntaxErrorException was thrown hence, this test passed.\\
		
				
		\item \textbf{Parse string by size test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the output of the parseString() method by using the size of clauses. This is done by first asserting the amount of clauses and then the amount of literals.\\\\
		\underline{Input}\\
		\indent The input as literal is \quotes{(x)(w,y,z)}\\	\\
		\underline{Expected Output}\\
		\indent The expected is 2 for the amount of clauses and 4 for the amount of literals.\\\\
		\underline{Actual Output}\\
		\indent The amount of clauses was 2 while the amount of literals was 4, hence, this test passed.\\
		
	\end{enumerate}
	
	\subsubsection{DPLLTest.java}
	
	This testing class includes unit tests to test all the functions used by the DPLL algorithm and it also contains integration tests to make sure that the DPLL algorithm returns the expected results. It should also be noted that in order to test the implementation better, another symbol \quotes{v} was implemented.\\
	Below, one can find some unit tests and some of the integration tests performed. Not all tests were listed here for the sake of the length of this document since some are repetitive.
	
	\begin{enumerate}
	\item \textbf{DPLL Integration test 1}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x, !y, z)(v, w, y)(v, !x, !z)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true since it is a satisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was true, hence, the test passed. Moreover, an assignment was printed out and can be seen in the image below. This makes sense because if we put x and v as true in the input expression, the expression can be solved. 
			\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest1.png}
			 			\centering
			  			\caption{Test result for (x, !y, z)(v, w, y)(v, !x, !z)}
			  			\label{fig:dplltest1}
					\end{figure}
					
					
		\item \textbf{DPLL Integration test 2}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x, y, z)(x, !y)(y, !z)(z, !x)(!x, !y, !z)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be false since it is an unsatisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was false, hence, the test passed. Moreover, UNSAT is printed to show that there is no possible assignment for this expression. 
				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest2.png}
			 			\centering
			  			\caption{Test result for (x, y, z)(x, !y)(y, !z)(z, !x)(!x, !y, !z)}
			  			\label{fig:dplltest2}
					\end{figure}
					
					
				\item \textbf{DPLL Integration test 3 - trivially unsatisfiable}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x)(!x)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be false since it is an unsatisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was false, hence, the test passed. Moreover, UNSAT is printed to show that there is no possible assignment for this trivially unsatisfiable expression. 
				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest2.png}
			 			\centering
			  			\caption{Test result for (x)(!x)}
			  			\label{fig:dplltest3}
					\end{figure}
					
					\item \textbf{DPLL Integration test 4}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(!x)(!x,y)(!x,z)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true since it is a satisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was true, hence, the test passed. Moreover, an assignment was printed out and can be seen in the image below. This makes sense because if we put x as false in the input expression, the expression can be solved. 
				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest4.png}
			 			\centering
			  			\caption{Test result for (!x)(!x,y)(!x,z)}
			  			\label{fig:dplltest4}
					\end{figure}		

\item \textbf{DPLL Integration test 5}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(!x,y)(!x,z)(y,z)(w,!y)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true since it is a satisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was true, hence, the test passed. Moreover, an assignment was printed out and can be seen in the image below. This makes sense because if we put x as false and y and z as true in the input expression, the expression can be solved. 
				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest5.png}
			 			\centering
			  			\caption{Test result for (!x,y)(!x,z)(y,z)(w,!y)}
			  			\label{fig:dplltest5}
					\end{figure}		
		
\item \textbf{DPLL Integration test 6}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(w)(x, !y)(z,x)(y,!x)(x, !x)(z, !y)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true since it is a satisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was true, hence, the test passed. Moreover, an assignment was printed out and can be seen in the image below. This makes sense because if we put all x, z, y and w as true in the input expression, the expression can be solved. 
								\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest6.png}
			 			\centering
			  			\caption{Test result for (w)(x, !y)(z,x)(y,!x)(x, !x)(z, !y)}
			  			\label{fig:dplltest6}
					\end{figure}	
					
					\item \textbf{DPLL Integration test 7}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x,y)(w)(!x, z)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true since it is a satisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was true, hence, the test passed. Moreover, an assignment was printed out and can be seen in the image below. This makes sense because if we put all w and y as true and x as false in the input expression, the expression can be solved. 

				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest7.png}
			 			\centering
			  			\caption{Test result for (x,y)(w)(!x, z)}
			  			\label{fig:dplltest7}
					\end{figure}	
					
										\item \textbf{DPLL Integration test 8}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x,y)(x,z)(!y, !z)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true since it is a satisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was true, hence, the test passed. Moreover, an assignment was printed out and can be seen in the image below. This makes sense because if we put all x as true and y as false in the input expression, the expression can be solved. 

				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest8.png}
			 			\centering
			  			\caption{Test result for (x,y)(x,z)(!y, !z)}
			  			\label{fig:dplltest8}
					\end{figure}	
					
															\item \textbf{DPLL Integration test 9}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x)(!x, y)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true since it is a satisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was true, hence, the test passed. Moreover, an assignment was printed out and can be seen in the image below. This makes sense because if we put all x and y as true in the input expression, the expression can be solved. 

				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest9.png}
			 			\centering
			  			\caption{Test result for(x)(!x, y)}
			  			\label{fig:dplltest9}
					\end{figure}		
					
							\item \textbf{DPLL Integration test 10}\\\\
		\underline{Description}\\
		\indent This is an integration test for the DPLL() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(y,!z,w,!x)(y)(y,!x)(y,w)(!z)(x,!z)(w, !x)(w, x)(!x)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true since it is a satisfiable expression.\\\\
		\underline{Actual Output}\\
		The output was true, hence, the test passed. Moreover, an assignment was printed out and can be seen in the image below. This makes sense because if we put all w and y as true and x and z as false in the input expression, the expression can be solved. 

				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.7\textwidth]{dplltest10.png}
			 			\centering
			  			\caption{Test result for (y,!z,w,!x)(y)(y,!x)(y,w)(!z)(x,!z)(w, !x)(w, x)(!x)}
			  			\label{fig:dplltest10}
					\end{figure}		
					
		\item \textbf{Trivially UNSAT false test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the checkTriviallyUnSat() method by passing an expression which is not trivially unsatisfiable\\\\
		\underline{Input}\\
		\indent The input is \quotes{(x,y)(x,z)(!x,y)}\\\\
		\underline{Expected Output}\\
		\indent The expected output is false.\\\\
		\underline{Actual Output}\\
		\indent The output was false, hence, this test passed.\\
		
		\item \textbf{Trivially UNSAT true test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the checkTriviallyUnSat() method by passing an expression which is trivially unsatisfiable\\\\
		\underline{Input}\\
		\indent The input is \quotes{(x)(x,z)(!x,y)(!x)}\\\\
		\underline{Expected Output}\\
		\indent The expected output is true.\\\\
		\underline{Actual Output}\\
		\indent The output was true, hence, this test passed.\\
		
		\item \textbf{Remove trivially SAT test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the output of the removeTriviallySat() method by size when given an expression with trivially satisfiable clauses\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x,!x)(y)(!z,z)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be a set of clauses with size 2 less than the initial amount of clauses in the input, therefore, 1.\\\\
		\underline{Actual Output}\\
		\indent The output was a set of clauses with size 2 less than the initial amount of clauses, hence, this test passed.\\
		
		\item \textbf{Check empty clause false test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the output of the checkEmptyClause() method when given no empty clauses in the expression\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x,!x)(y)(!z,z)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be false.\\\\
		\underline{Actual Output}\\
		\indent The output was false, hence, this test passed.\\
		
		\item \textbf{Check empty clause true test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the output of the checkEmptyClause() method when given an empty clauses in the expression\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x,!x)(y)(!z,z)()}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be true.\\\\
		\underline{Actual Output}\\
		\indent The output was true, hence, this test passed.\\
		
		\item \textbf{Exhaustively apply 1 Literal Rule test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the output of the exhaustivelyApply1LiteralRule() function by size  when given an expression where the 1 literal rule can be applied\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(x)(!x)(y,z)} with \quotes{(x)} being he literal to be used to apply the 1 literal rule on the expression\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be that 2 clauses will be left from the expression.\\\\
		\underline{Actual Output}\\
		\indent The output was 2, hence, this test passed.\\
		
		\item \textbf{Get pure literal test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the output of the getPureLiteral() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(!x)(y, !x)(!x, w)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be the the literal \quotes{$\neg$x}.\\\\
		\underline{Actual Output}\\
		\indent The output was literal \quotes{$\neg$x}, hence, this test passed.\\
		
		\item \textbf{Apply pure literal exhaustively test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the output of the applyPureLiteralRule() function by size\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(!x)(y, x)(z,w)(y, w)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be 0, because all the clauses would be absorbed.\\\\
		\underline{Actual Output}\\
		\indent The output was 0, hence, this test passed.\\
		
		\item \textbf{Test choose literal test}\\\\
		\underline{Description}\\
		\indent This purpose of this test is to test the output of the chooseLiteral() function\\\\
		\underline{Input}\\
		\indent The input as expression is \quotes{(y)(!x)(y, x)(!y,z)(y, w)}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be the literal \quotes{y} because our function uses DLIS and \quotes{y} is the most common.\\\\
		\underline{Actual Output}\\
		\indent The output was the literal \quotes{y}, hence, this test passed.\\
		
		
		
	\end{enumerate}
	

				
	



										

					
				
		
								
					
			\subsection{Practical Applications of SAT}
			
			Just like everything else, anything which is not practical is not very useful. Boolean Satisfiability have been going through improvements throughout the years in order to be used in a practical environment to help in producing a better end product. Moreover, in some
applications, the use of SAT solvers improves performance remarkably \cite{pa3}. The most common applications can be split into 
\begin{itemize}
\item\textbf{product configuration} which involves formulating model lines,  dependencies between components and adhering to customer's restrictions \cite{pa2}.
\end{itemize}
  hardware verification which includes checking the correctness of hardware designs at gate-level and properties related to temporal logic\cite{pa1}.	\\\\
The most well known practical applications include:

\begin{enumerate}
\item \textbf{Combinational Equivalence Checking} : One of the uses of SAT applications checking the equivalence of two circuits, namely, combinational circuits\cite{pa3}. 
\item \textbf{ATPG and SSF} : SAT is used in Automatic Test-Pattern Generation and Single Stuck-at Fault models to be able to identify  fabrication defects in integrated circuits respectively\cite{pa3}. These defects introduce a possibility of of circuit failure and hence, as explained above, SAT helps in making these models better, hence being able to identify and represent the faults ore robustly.
\item \textbf{Bounded Model Checking}: A model checking question asks to show that property always holds while a bounded model checking question asks whether there is a path which contradicts the property, or in other terms, a path which satisfies a failing property. SAT is used in the bounded model checking algorithms which are very common nowadays and are accepted by big companies such as Intel, AMD and IBM\cite{pa1}.
\item \textbf{Planning}: SAT is also used in systems when it comes to planning. In fact, Artificial Intelligence planning was the first push to SAT being used as a practical application\cite{pa3} and from this, a lot of other opportunities were opened for SAT to be used in the areas explained above. This works in a similar way to BMS, hence, increasing the length of paths until the SAT is unsatisfiable. Different types of planning applications include time-tables, air-traffic control and telegraph routing\cite{pa1}. In addition, scheduling of events can also be considered as a practical application of SAT.

	To conclude, as can be seen from the above descriptions, usually SAT algorithms must be able to prove unsatisfiability. The best thing about is as time goes by better variable selection heuristics will be found and the implementation of SAT will be even more efficient and optimized. 

\end{enumerate}


		\subsection{Evaluation and Conclusion}
		
		I managed to complete all the tasks required for this task in the specification. Following the course notes step by step and implementing a feature after the other, made it pretty much simple to come up with the solution which I have implemented. In relation to the heuristic which I had to implement for the chooseLiteral() method, I had to conduct more research from which I found different interesting implementations. Some where more complex than the others but after consulting with the lecturer, I sticked to the DLIS heuristic. Moreover, for the part were I had to discuss several practical applications of SAT, I managed to find two papers which were quite detailed and hence, made it easier to understand and discuss the different types of applications. Finally, I can conclude that since all the tests passed as expected, my implementation works as expected and is robust, since it fails gracefully when it should.

\pagebreak


		\section{Task2: Data	Compression}
		
		For part 2 of this assignment, it was required to write a command line program which should accept an ASCII text file as input with the only characters allowed being \textbf{A-Z}, \textbf{a-z} and \textbf{0-9}. Moreover, if the file contains any other characters, an error was required to be shown. More importantly, Huffman coding was required to be implemented to produce the optimal coding tree for the file contents. Finally, the coding table needed to be displayed and sorted by ASCII value. 
		
		\subsection{Solution}
		
		\subsubsection{CharacterNotSupportedException.java}
		
		This is an exception class which is thrown when an input file contains an unsupported character.
		
		\subsubsection{NoFilePassedException.java}
		
		This is an exception class which is thrown when no file name is passed to the command line arguments of the executor.
		
		
		\subsubsection{FileOperation.java}
		
		This is a class which contains the method to read a file and initialise the member variables of the DPLL class in order to begin doing the huffman coding of the file.
		
		This method is called \textbf{populateInitFrequencies()} and it accepts the path to the file in a string as a parameter. In order to populate and intiliase the character frequencies the following is done.
		
		\begin{enumerate}
			\item A buffered reader is created for the file which is located at  the specified path.
			\item Then for every character:
				\begin{enumerate}
					\item The next character is obtained
					\item It is checked if this character falls in the region of ASCII codes accepted and if not a \textbf{CharacterNotSupportedException} is thrown.
					\item It is checked if the character is already defined in the hashmap holding frequencies of characters and then if it is already defined, the frequency is incremented. Otherwise, a new map entry for the character is created.
				\end{enumerate}
\item A new priority queue is declared using the NodeComparator which I will be explaining further down below. A priority queue is a normal queue with the added feature of each queue object has an attached priority, in this case, the least frequent sits at the top. 
\item Each item in the frequency table is added to the priority queue.
		\end{enumerate}
		
				\subsubsection{Node.java}
		
		This file contains the following two classes:
		\begin{enumerate}
			\item \textbf{NodeComparator}: This is a Comparator class containing the compare method which checks the difference between the two nodes so that it can be used to give priority to each object for the priority queue.
			\item \textbf{Node}: This is a class used to represent a Huffman coding node. 
		\end{enumerate}
		
		The Node class contains the following global variables:
		\begin{itemize}
			\item \textbf{frequency}: This is a variable to hold the frequency, hence, the number of times it appears in the file.
			\item \textbf{character}: This is a variable to hold the character
			\item \textbf{left}: This is a Node object which represent the child left node. This contains a smaller value than the right node.
			\item \textbf{right}: This is a Node object which represent the child right node
		\end{itemize}
		
		Moreover, it contains the following methods: 
		
		\begin{enumerate}
		\item \textbf{Node(int, char)}: The is a constructor which sets the frequency and character.
		\item \textbf{Node(int, char, Node, Node)}: The is a constructor which sets the frequency, character and left and right nodes.
		\item \textbf{getCharacter()}: This is a getter for the character.
		\item \textbf{getFrequency()}: This is a getter for the frequency.
		\end{enumerate}
		
		
		\subsubsection{HuffmanCoding.java}
		
		This is a class which contains the methods to perform huffman coding. To start with, it contaisn the following member variables:
		\begin{itemize}
			\item \textbf{frequencies}: This is a hashmap with a key of type Character and a value of type int. It is used to hold how many times a character appears in the input file.
			\item \textbf{sortedChars}: As explained above, this is a priority queue which sorts the nodes according to the frequency. The least frequent is at the top.
			\item \textbf{codes}: This is a treemap with a key of type Character and a value of type string. This is used to hold the codes sorted by the ASCII code of the character.
			\item \textbf{root}: This is a Node object which holds the root node of the huffman coding tree.
		\end{itemize}
		
		Moreover, it contains the following methods: 
		
		\begin{enumerate}
		\item \textbf{buildTree()}: This is a method used to build the huffman coding tree. This is done by having a while loop going on until there is only 1 node left in the priority queue. In this loop the following is done:
		\begin{itemize}
			\item The smallest two nodes are obtained by polling the first two nodes from the priority queue. 
			\item A new frequency is computed by adding the frequency of the two nodes obtained.
			\item A new node is created with a \quotes{\#} character, the frequency computed in the previous step the second smallest node as the right node and the smallest node as the left node.
			\item This new node is added to the sorted chars and the new node is set as the root of the huffman coding class..
		\end{itemize}
		
		\item \textbf{printCodes()}: This is a method which loops through the codes and prints them one by one
		\item \textbf{generateCodes(Node, String)}: This is a method which generates the codes recursively for each character. The node passed is the parent node while the string passed represents the code. This is done by first getting the character of the top node. Then it is chece=ked whether the left child node of the top node is null, if so, it means that it is a leaf node and hence, the character and its corresponding code are inserted in the hashmap \textbf{codes} holding the codes. Finally, first a recursibve call is called on the right node with a new code consisting of the current code with a \quotes{1} added at the end and then another recursive call is made on the left but this time with a new code consisting of the current code with a \quotes{0} added at the end.
		\item \textbf{getShortest()}: This is a function which gets the shortest code and is used for testing the Huffman coding end results. This is done by first setting a variable holding the shortest length to the maximum value of integer and a variable holding the shortest character to null. After this, every code in the hashmap \textbf{codes} is traversed and for each code it is checked if its length is shorter than the current shortest. If so, the two variables holding the shortest length and the corresponding character of the code with the shortest length are set to the current character. Finally, the shortest character is printed and it is returned.
		
				\item \textbf{reset()}: This is a function which resets all the global variables and is in fact used for testing.
				
				\item \textbf{getCodes()}: This is a getter function for the treemap containing codes.
				\item \textbf{getFrequencies()}: This is a getter function for the hashmap containing frequencies.
				\item \textbf{getSortedChars()}: This is a getter function for the priority queue containing huffman coding nodes.
				\item \textbf{getRoot()}: This is a getter function for the root node of the huffman coding tree.
				\item \textbf{setSortedChars(PriorityQueue\textless Node\textgreater)}: This is a setter function to set the priority queue containing huffman coding nodes.
				
				

		\end{enumerate}
		
		\subsection{How to run}

In order to run the implementation for task 2, an additional class named \textbf{HuffmanCodingExecutor} was created and in its main method, the command line arguments are obtained. First it is checked if the any filenam is passed and i not, a \textbf{NoFilePassedException} is thrown. Otherwise, the filename of the input file is obtained from the arguments and by calling the function \textbf{populateInitFrequencies(String)}, the frequencies of each character are populated. Then, the function \textbf{buildTree()} to build the tree and is followed by calling \textbf{generateCodes()} with the root node and an empty string. Finally, the codes are printed by calling \textbf{printCodes()}. \textbf{It is important to note that the quotes before and after the file name may change according to the machine}.

\begin{enumerate}
\item Go to the directory \quotes{DSA2}
\item Run \textbf{java -jar .\textbackslash Task2-1.0.jar \quotes{\textless anyFilePath\textgreater}}
\end{enumerate}

		\subsection{Testing}

In order to test the implementation for task 2, an additional testing class named \textbf{HuffmanCodingTest} was created and this involves numerous integration tests which basically performs Huffman coding on a file and asserts the shortest code. Apart from these integration tests, some unit tests  were created to test exceptions such as the \textbf{NoFilePassedException} in the executor and the \textbf{CharacterNotSupportedException} found in the FileOperation class where the file is parsed.

The integration tests performed can be found below. It is important to note that not all tests found in the code are listed here because otherwise this document would be too long. This was decided since the tests omitted are similar to the ones listed.

\begin{enumerate}
	\item \textbf{Huffman Coding Integration test 1}\\\\
		\underline{Description}\\
		\indent This is an integration test for the HuffmanCoding() function. This is done by when given an input file with several characters, the number of different codes and the the character with the shortest code is asserted. The character with the shortest code should be the most frequent character in the input stream.\\\\
		\underline{Input}\\
		\indent The contents of the input file were \quotes{aaaaabbbbbbbbbccccccccccccdddddddddddddeeeeeeeeeeeeeeeefffffffffffffffffffffffffffffffffffffffffffff}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be `f' as the character having the shortest code and 6 as the number of different codes.\\\\
		\underline{Actual Output}\\
		The output was `f' as the character with the shortest code and 6 as the number of different code, hence, the test passed. This can be easily confirmed by counting the number of different characters and and seeing the most frequent character from the file input stream.
			\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.4\textwidth]{hctest1.png}
			 			\centering
			  			\caption{Test result for \quotes{aaaaabbbbbbbbbccccccccccccdddddddddddddeeeeeeeeeeeeeeeefffffffffffffffffffffffffffffffffffffffffffff}}
			  			\label{fig:dplltest1}
					\end{figure}
					
					\item \textbf{Huffman Coding Integration test 2}\\\\
		\underline{Description}\\
		\indent This is an integration test for the HuffmanCoding() function. This is done by when given an input file with several characters, the number of different codes and the the character with the shortest code is asserted. The character with the shortest code should be the most frequent character in the input stream.\\\\
		\underline{Input}\\
		\indent The contents of the input file were \\ \quotes{111111122222333jisjiajsadgwwbhdwwbdDDDDDDDDDDDDDDDDDDDDDDDDDDDDaaaaaa}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be `D' as the character having the shortest code and 13 as the number of different codes.\\\\
		\underline{Actual Output}\\
		The output was `D' as the character with the shortest code and 13 as the number of different code, hence, the test passed. This can be easily confirmed by counting the number of different characters and and seeing the most frequent character from the file input stream.
				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.4\textwidth]{hctest2.png}
			 			\centering
			  			\caption{Test result for \quotes{111111122222333jisjiajsadgwwbhdwwbdDDDDDDDDDDDDDDDDDDDDDDDDDDDDaaaaaa}}
			  			\label{fig:hctest2}
					\end{figure}
					
					
					\item \textbf{Huffman Coding Integration test 3}\\\\
		\underline{Description}\\
		\indent This is an integration test for the HuffmanCoding() function. This is done by when given an input file with several characters, the number of different codes and the the character with the shortest code is asserted. The character with the shortest code should be the most frequent character in the input stream.\\\\
		\underline{Input}\\
		\indent The contents of the input file were \quotes{aabc}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be `b' as the character having the shortest code and 3 as the number of different codes.\\\\
		\underline{Actual Output}\\
		The output was `b' as the character with the shortest code and 3 as the number of different code, hence, the test passed. This can be easily confirmed by counting the number of different characters and and seeing the most frequent character from the file input stream.
				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.4\textwidth]{hctest4.png}
			 			\centering
			  			\caption{Test result for\quotes{abbc}}
			  			\label{fig:hctest4}
					\end{figure}
					
										\item \textbf{Huffman Coding Integration test 4}\\\\
		\underline{Description}\\
		\indent This is an integration test for the HuffmanCoding() function. This is done by when given an input file with several characters, the number of different codes and the the character with the shortest code is asserted. The character with the shortest code should be the most frequent character in the input stream.\\\\
		\underline{Input}\\
		\indent The contents of the input file were \quotes{AhsuahdbhAAAAAncuwhwdhAAAAAAajncuhwcuwcwww82787AAAAAAAAAxnjhuwbwdhwdwhdAAAAAAAAAAAAAAA}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be `A' as the character having the shortest code and 15 as the number of different codes.\\\\
		\underline{Actual Output}\\
		The output was `A' as the character with the shortest code and 15 as the number of different code, hence, the test passed. This can be easily confirmed by counting the number of different characters and and seeing the most frequent character from the file input stream.
				\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.45\textwidth]{hctest5.png}
			 			\centering
			  			\caption{Test result for \quotes{AhsuahdbhAAAAAncuwhwdhAAAAAAajncuhwcuwcwww82787AAAAAAAAAxnjhuwbwdhwdwhdAAAAAAAAAAAAAAA}}
			  			\label{fig:hctest5}
					\end{figure}
					
					
					\item \textbf{Huffman Coding Integration test 5}\\\\
		\underline{Description}\\
		\indent This is an integration test for the HuffmanCoding() function. This is done by when given an input file with several characters, the number of different codes and the the character with the shortest code is asserted. The character with the shortest code should be the most frequent character in the input stream.\\\\
		\underline{Input}\\
		\indent The contents of the input file were \quotes{NCHJKWKIZZZZZZZZZZZZZZZZZZZZZnxuwbwjnxwZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZwuwbdhbwdbwjdbwdwwdkwZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZansuqnuiqdjwqiudqjbqwvubhbwbuhqwjwxu18726728912412bhjvdjwhqbDDDANHADNAXHWM}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should be `Z' as the character having the shortest code and 33 as the number of different codes.\\\\
		\underline{Actual Output}\\
		The output was `Z' as the character with the shortest code and 33 as the number of different code, hence, the test passed. This can be easily confirmed by counting the number of different characters and and seeing the most frequent character from the file input stream.
									\begin{figure}[H]
					\centering
			 			\includegraphics[width=0.4\textwidth]{hctest3.png}
			 			\centering
			  			\caption{Test result for \quotes{NCHJKWKIZZZZZZZZZZZZZZZZZZZZZnxuwbwjnxwZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZwuwbdhbwdbwjdbwdwwdkwZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZansuqnuiqdjwqiudqjbqwvubhbwbuhqwjwxu18726728912412bhjvdjwhqbDDDANHADNAXHWM}}
			  			\label{fig:hctest3}
					\end{figure}
					
					
					\item \textbf{Unsupported character test}\\\\
		\underline{Description}\\
		\indent This is an integration test for the reaction of the populateInitFrequencies() function when given an unsupported character.\\\\
		\underline{Input}\\
		\indent The contents of the input file were \quotes{\}}\\	\\
		\underline{Expected Output}\\
		\indent The expected output should a CharacterNotSupportedException being thrown.\\\\
		\underline{Actual Output}\\
		The output was a thrown CharacterNotSupportedException, hence, the test passed
		
							\item \textbf{No file passed exception test}\\\\
		\underline{Description}\\
		\indent This is an integration test for the reaction of the runner class main function when no file path is passed\\\\
		\underline{Input}\\
		\indent There was no file path passed as input\\	\\
		\underline{Expected Output}\\
		\indent The expected output should a NoFilePassedException being thrown.\\\\
		\underline{Actual Output}\\
		The output was a thrown NoFilePassedException, hence, the test passed
		
		\item \textbf{No file found exception test}\\\\
		\underline{Description}\\
		\indent This is an integration test for the reaction of the runner class main function when an inexistent file path is passed\\\\
		\underline{Input}\\
		\indent An inexistent file path is passed as argument\\	\\
		\underline{Expected Output}\\
		\indent The expected output should a FileNotFoundException being thrown.\\\\
		\underline{Actual Output}\\
		The output was a thrown FileNotFoundException, hence, the test passed
					
					\end{enumerate}


		\subsection{Evaluation and Conclusion}
		
		I managed to complete all the tasks required in the specification. I followed the course notes and an article explaining the algorithm\cite{hc}, where I got the hang of how Huffman's algorithm works, the importance of having an optimal coding tree and the correct way of building the tree. After this, I realized that Java's PriorityQueue data structure would be perfect for this scenario as it would keep the nodes sorted by their frequencies. After having the design of the flow in my mind, It was easy constructing the methods which when called after each other, performs Huffman coding as expected. Moreover, I think that my implementation works as expected and is robust, since it fails gracefully when it should and passes all the tests.
				
				
				


					

					

					
					
					
			
			
		\bibliographystyle{ieeetr}
		\nocite{*}
\bibliography{references}
			
		
			
					
			\end{document}

